st1 = set(range(1, 9))
st2 = set(range(9, 20))
st3 = set(range(7, 17))
st4 = frozenset(range(5, 20))
print(st1 & st2 & st3)
print(st1 | st2 | st3)
print(st1 ^ st2 ^ st3)
st1.add(9)
print(st1 & st2 & st3)
st2.discard(17)
st3.pop()
print(st1 & st2 & st3)
st1.clear()
print(st1 ^ st2 ^ st3)
print(st4 & st3)
print(st3 ^ st4)
print(st4 | st3)

# 3

"""1. Создать произвольный словарь
2. Добавить новый элемент с ключом типа str и значением типа int
3. Добавить новый элемент с ключом типа кортеж(tuple) и значением
типа список(list)
4. Получить элемент по ключу
5. Удалить элемент по ключу
6. Получить список ключей словаря"""

# 4
"""Преобразовать текст в множество слов с удалением знаков препинания.
Например: python, JS! C? преобразуется в python JS C """

str = "python, JS! C?"
for i in str:
    if i in ":;.?!,":
        str = str.replace(i, "")
st = set(str.split())
print(st)

# dz

"""Задача №1
Придумать задачу, в которой будет использование множества.

Задача: Даны два множества A и B. Необходимо вычислить множество,
содержащее все возможные комбинации элементов из A и B."""

A = set("python")
B = set("dict&set")
result = set()
for a in A:
    for b in B:
        result.add((a, b))
__import__("pprint").pprint(result)
print(f"len = {len(result)}")

"""Задача №2

Закрепить теорию по спискам, кортежам, словарям и множествам. Сделать вывод
что из этого более удобно и эффективно, либо всё индивидуально. Свои выводы
доказать и по возможности продемонстрировать на практике. """

# list - список, изменяемый упорядоченный, обычно хранит значения одного типа,
# О(1) доступ к элементу
# tuple - кортеж, неизменяемый упорядоченный, обычно хранит значения разных типов,
# О(1) доступ к элементу

# используй кортежи везде, где это возможно и обоснованно
# 1) используй [] для создания пустого списка ({} для словаря)
# 2) если заранее известен размер, то не используй append
# 3) используй листкомпс
# 4) не пытайся заменять список кортежом, там где идет изменение размера
#
# 1) dict - словарь, отображение, хеш-мап, ассоциативный массив,
# коллекция пар ключ-значение, где ключом может быть только hashable тип,
# доступ по ключу и проверка наличия ключа O(1),
# с питона 3.7 хранит порядок вставки
# 2) пустой словарь создавать лучше через {},а не dict(), под капотом
# сразу будет создано 8 элементов
# 3) set - множество, хешсет, неупорядоченный набор hashable объектов,
# доступ и проверка наличия O(1)
# 4) frozenset  - неизменяемый брат множества
# 5) Hashable != Immutable, эти понятия часто путают, помните что это не одно и то же.
# 6) алгоритм работы словаря и сета: Получаем хеш
# -> высчитываем позицию в массиве
# -> если элемента нет то действуем соответственно задаче
# -> если элемент есть то сравниваем ключ == тому что ищем
# -> если ключ не равен искомому то ищем дополнительный бакет
# 7) По умолчанию самописные классы возвращают хеш основанный на id,
# если переопределяете хеш, то всегда проверяйте,
# что у равных объектов одинаковый хеш
#
# 8) Проверка на содержание тоже вызывает ошибку, если элемент не хешируем.
# Тапл можно положить в сет только если все его элементы хешируемы,
# frozenset без проблем кладется в сет. Словари и сеты нельзя положить
# в словари(как ключ) и сеты.
# 9) За скорость словаря и сета мы платим большей памятью и тем,
# что положить туда можно не любые элементы
