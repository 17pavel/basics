****** 
PEP-8 https://www.python.org/dev/peps/pep-0...
стандартные функции https://docs.python.org/3.8/library/f...

# Именование! Называем вещи своими именами, коллекции во множественном числе, функции -что делают
# Всегда используем ф-строки, НИКОГДА не складываем строки
# не делаем то, что происходит по-умолчанию (str(input))
# используем листкомпс и генэксп только если есть преобразование И/ИЛИ фильтрация
# лучше листкомпс, генэксп, чем map/filter
# используем while True для вечных циклов
# если список не нужен, используем генэксп
# не используем range (len(list)), если нужен индекс то используем enumerate
# используем if collection чтобы проверить что не пустая
# используем встроенные функции
# ловим конкретное исключение, пишем информацию в ветке except

***листкомпс и генэксп***
1) все компсы и генэксп работают по принципу
[ВЫРАЖЕНИЕ/ПРЕОБРАЗОВАНИЕ for element in ИСТОЧНИК if УСЛОВИЕ]
читается это слева направо, что важно когда циклов больше 1.
2) принцип работы операций у листкомпс и генэксп одинаков, синтаксически различаются скобками
3) компсы (листкомпс, сеткомпс, дикткомпс) в результате своей работы формируют соответствующую коллекцию и занимают память
4) переменные созданные внутри компсов или генэкспа недоступны извне
5) генэксп вернет объект, а не коллекцию! при создании объекта он проверит источник, что может быть критично, если это какая
то функция. Если источник не валидный то ошибка упадет при создании генератора, а не при попытке получить значение
6) генэксп ленивый, то есть ничего не делает и не занимает память пока не потребуется значение. Сгенерировав значение снова
засыпает пока опять не попросят новое.
7) генэксп одноразовый, при исчерпании начинает бросать исключение, которое мы не увидим, если используем генератор в цикле for
8) генэксп может потенциально генерировать бесконечные последовательности, но он ничего не знает о порядке элементов или о их количестве (нет len)

Лично мое мнение -  если вам не нужна длина, слайсы, индексы, то нужно использовать генэскп, не только из-за экономии памяти,
но и из-за ленивости, экономии процессорного времени.
Естественно важно помнить что даже pep-8 и дзен - это не закон, а рекомендации, наша конкретная реализация и подход должны
диктоваться имеющимися условиями и решаемой задачей.

***list, tuple***

#list - список, изменяемый упорядоченный, обычно хранит значения одного типа, О(1) доступ к элементу
#tuple - кортеж, неизменяемый упорядоченный, обычно хранит значения разных типов, О(1) доступ к элементу

# используй кортежи везде, где это возможно и обоснованно
# 1) используй [] для создания пустого списка ({} для словаря)
# 2) если заранее известен размер, то не используй append (для 8000 добавлений выделяется 8600 ячеек памяти)
# 3) используй листкомпс
# 4) не пытайся заменять список кортежом, там где идет изменение размера

***dict, set***
1) dict - словарь, отображение, хеш-мап, ассоциативный массив, коллекция пар ключ-значение,
где ключом может быть только hashable тип, доступ по ключу и проверка наличия ключа O(1), с питона 3.7 хранит порядок вставки
2) пустой словарь создавать лучше через {},а не dict(), под капотом сразу будет создано 8 элементов
3) set - множество, хешсет, неупорядоченный набор hashable объектов, доступ и проверка наличия O(1) 
4) frozenset  - неизменяемый брат множества
5) Hashable != Immutable, эти понятия часто путают, помните что это не одно и то же.
6) алгоритм работы словаря и сета: Получаем хеш -} высчитываем позицию в массиве
-> если элемента нет то действуем соответственно задаче
-> если элемент есть то сравниваем ключ == тому что ищем
-> если ключ не равен искомому то ищем дополнительный бакет
7) По умолчанию самописные классы возвращают хеш основанный на id, если переопределяете хеш,
то всегда проверяйте, что у равных объектов одинаковый хеш

8) Проверка на содержание тоже вызывает ошибку, если элемент не хешируем.
Тапл можно положить в сет только если все его элементы хешируемы, frozenset без проблем кладется в сет.
Словари и сеты нельзя положить в словари(как ключ) и сеты.
9) За скорость словаря и сета мы платим большей памятью и тем, что положить туда можно не любые элементы


Тема урока: кортежи
Тип данных tuple
Особенности работы с кортежами
Аннотация. Урок посвящен кортежам (тип данных tuple).

Мы изучили списки и строки. Списки – изменяемые коллекции, строки – неизменяемые последовательности Unicode символов.
В Python имеются и неизменяемые последовательности содержащие, в отличие от строк, абсолютно произвольные данные.
Такие коллекции называются кортежами (tuple, читается "тюпл").

Кортежи
Рассмотрим следующий программный код:

my_list = [1, 2, 3, 4, 5]
Мы объявили список чисел и присвоили его переменной my_list. Содержимое списка можно изменять.

Следующий программный код:

my_list = [1, 2, 3, 4, 5]
my_list[0] = 9
my_list[4] = 7
print(my_list)
выведет:

[9, 2, 3, 4, 7]
Заменив квадратные скобки при объявлении списка на круглые, мы объявляем кортеж:

my_tuple = (1, 2, 3, 4, 5)
Кортежи по своей природе (задумке) – неизменяемые аналоги списков. Поэтому программный код:

my_tuple = (1, 2, 3, 4, 5)
my_tuple[0] = 9
my_tuple[4] = 7
print(my_tuple)
приводит к ошибке

TypeError: 'tuple' object does not support item assignment
   Кортеж (tuple) – ещё один вид коллекций в Python. Похож на список, но, в отличие от списка, неизменяемый.

В литеральной форме кортеж записывается в виде последовательности элементов в круглых скобках, а список – в квадратных.

Примеры кортежей
empty_tuple = ()                                      # пустой кортеж
point = (1.5, 6.0)                                    # кортеж из двух чисел
names = ('Timur', 'Ruslan', 'Roman')                  # кортеж из трех строк
info = ('Timur', 'Guev', 28, 170, 60, False)          # кортеж из 6 элементов разных типов
nested_tuple = (('one', 'two'), ['three', 'four'])    # кортеж из кортежа и списка
в переменной empty_tuple хранится пустой кортеж;
в переменной point хранится кортеж, состоящий из двух вещественных чисел (такой кортеж удобно использовать
для представления точки на координатной плоскости);
в переменной names хранится кортеж, содержащий три строковых значения;
в переменной info содержится кортеж, содержащий 
6
6 элементов разного типа (строки, числа, булевы переменные);
в переменной nested_tuple содержится кортеж, содержащий другой кортеж и список.
Кортежи могут хранить и содержать в себе объекты любых типов (даже составных) и поддерживают неограниченное количество уровней вложенности.

Кортеж с одним элементом
Для создания кортежа с единственным элементом после значения элемента ставят замыкающую запятую:

my_tuple = (1,)
print(type(my_tuple))     # <class 'tuple'>
Если запятую пропустить, то кортеж создан не будет. Например, приведенный ниже код просто присваивает переменной my_tuple целочисленное значение 1:

my_tuple = (1)
print(type(my_tuple))     # <class 'int'>
Зачем использовать кортеж вместо списка?
Списки могут делать то же, что кортежи, и даже больше. Но неизменяемость кортежей обеспечивает им особые свойства:

скорость – кортежи быстрее работают, так как из-за неизменяемости хранятся в памяти иначе, и операции с их элементами выполняются заведомо быстрее,
чем с компонентами списка. Одна из причин существования кортежей  – производительность. Обработка кортежа выполняется быстрее, чем обработка списка,
поэтому кортежи удобны для обработки большого объема неизменных данных.
безопасность – неизменяемость превращает их в идеальные константы. Заданные кортежами константы делают код более читаемым и безопасным. Кроме того,
в кортеже можно безопасно хранить данные, не опасаясь, что они будут случайно или преднамеренно изменены в программе.
В Python существуют операции, требующие применения кортежа. По мере освоения языка Python вы будете чаще сталкиваться с кортежами.

Примечания
Примечание 1. Мы уже  сталкивались с кортежами, когда изучали функции, возвращающие несколько значений. Такие функции возвращают именно кортежи.

Рассмотрим функцию get_powers(), которая принимает в качестве аргумента число и возвращает его 
2
2, 
3
3 и 
4
4 степень.

def get_powers(num):
    return num**2, num**3, num**4
Результатом выполнения следующего кода:

result = get_powers(5)
print(type(result))
print(result)
будет:

<class 'tuple'>
(25, 125, 625)
Примечание 2. Списки предназначены для объединения неопределенного количества однородных сущностей. Кортежи, как правило,
объединяют под одним именем несколько разнородных объектов, имеющих различный смысл.

Примечание 3. Тот факт, что кортеж является неизменяемым вовсе не означает, что мы не можем поменять содержимое списка в кортеже.

Приведенный ниже код:

my_tuple = (1, 'python', [1, 2, 3])
print(my_tuple)
my_tuple[2][0] = 100
my_tuple[2].append(17)
print(my_tuple)
выводит:

(1, 'python', [1, 2, 3])
(1, 'python', [100, 2, 3, 17])
При этом важно понимать: меняется список, а не кортеж. Списки являются ссылочными типами данных, поэтому в кортеже хранится ссылка на список,
которая не меняется при изменении самого списка.
